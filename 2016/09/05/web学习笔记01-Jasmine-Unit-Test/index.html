<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Unit Test   单元测试概念（Unit Testing）&amp;#160;&amp;#160;&amp;#160;&amp;#160;又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。  单元测试必要性&amp;#160;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="web学习笔记01-Jasmine-Unit-Test">
<meta property="og:url" content="http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/index.html">
<meta property="og:site_name" content="点柈">
<meta property="og:description" content="Unit Test   单元测试概念（Unit Testing）&amp;#160;&amp;#160;&amp;#160;&amp;#160;又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。  单元测试必要性&amp;#160;&amp;">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1062695-257a5b3a23ce42f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1062695-c601eb879ca4f145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1062695-6660e7d9e385fb4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-09-21T06:09:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="web学习笔记01-Jasmine-Unit-Test">
<meta name="twitter:description" content="Unit Test   单元测试概念（Unit Testing）&amp;#160;&amp;#160;&amp;#160;&amp;#160;又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。  单元测试必要性&amp;#160;&amp;">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1062695-257a5b3a23ce42f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>web学习笔记01-Jasmine-Unit-Test</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="点柈" type="application/atom+xml" />
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="https://github.com/Yulingsong">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2016/09/12/web学习笔记02-基于Karma和Jasmine的AngularJS单元测试/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2016/09/02/iOS学习笔记01-自定义简单弹出pickerView/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&text=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&is_video=false&description=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=web学习笔记01-Jasmine-Unit-Test&body=Check out this article: http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&name=web学习笔记01-Jasmine-Unit-Test&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">Unit Test</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">1.0.1.</span> <span class="toc-text">单元测试概念（Unit Testing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">1.0.2.</span> <span class="toc-text">单元测试必要性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">Jasmine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">搭建环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.下载源文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">jasmine基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">2.四个核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.1.</span> <span class="toc-text">Jasmine四个核心概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.2.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.3.</span> <span class="toc-text">用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.4.</span> <span class="toc-text">期望</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.5.</span> <span class="toc-text">匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.6.</span> <span class="toc-text">其他matchers：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">3.Setup和Teardown方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">结果如图所示:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.3.</span> <span class="toc-text">4.describe函数的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.4.</span> <span class="toc-text">5.禁用Suites,挂起Specs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.</span> <span class="toc-text">6.Spy追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.1.</span> <span class="toc-text">    Jasmine具有函数的追踪和反追踪的双重功能，这东西就是Spy。Spy能够存储任何函数调用记录和传入的参数，Spy只存在于describe和it中，在spec执行完之后销毁。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.2.</span> <span class="toc-text">    and.callThrough–spy链式调用and.callThrough后，在获取spy的同时，调用实际的函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.3.</span> <span class="toc-text">    and.returnValue–spy链式调用and.returnValue 后，任何时候调用该方法都只会返回指定的值，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.4.</span> <span class="toc-text">    and.callFake–spy链式添加and.callFake相当于用新的方法替换spy的方法 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.5.</span> <span class="toc-text">    and.throwError–spy链式调用and.callError后，任何时候调用该方法都会抛出异常错误信息: </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.6.</span> <span class="toc-text">    and.stub–spy恢复到原始状态，不执行任何操作。直接看下代码: </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.7.</span> <span class="toc-text">    Spy的其他方法  </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.8.</span> <span class="toc-text">参考：</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        web学习笔记01-Jasmine-Unit-Test
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">点柈</span>
      </span>
      
    <div class="postdate">
        <time datetime="2016-09-05T13:57:58.000Z" itemprop="datePublished">2016-09-05</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2>Unit Test</h2>

<ul>
<li><p></p><h4>单元测试概念（Unit Testing）</h4><br>&#160;&#160;&#160;&#160;又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。<p></p>
</li>
<li><p></p><h4>单元测试必要性</h4><br>&#160;&#160;&#160;&#160;随着项目规模的增加，函数、方法、变量都在递增，维护的难度不断加大，以及测试提出的各种bug导致修改代码的时候会将原本整洁的代码变得混乱。<br>&#160;&#160;&#160;&#160;经常出现同一个接口以不同的名称出现在不同的控制器中，这个时候往往会去重构代码，但是重构代码的时候没人会保证自己将万无一失，重构的代码还是正确的，方法一样跑通等等。这个时候就需要单元测试了，单元测试是一个衡量标准，告诉开发人员这么做是否将改变结果。保证重构后的代码的兼容性，减少人力测试的过程，降低维护成本。<p></p>
</li>
</ul>
<h2>Jasmine</h2>


<p>&#160;&#160;&#160;&#160;Jasmine是一个behavior-driven development ( 行为驱动开发 ) 测试框架， 不依赖于任何其他JavaScript框架， 不依赖DOM， 并且有很简洁的语法让你能够很轻松的编写单元测试。它既可以在html文件中运行，也可以和jsTestDriver整合，在jsTestDriver中运行。</p>
<ul>
<li><p>BDD 行为驱动开发，是一种新的敏捷开发方法。相对于TDD(测试驱动开发)，它更趋向于需求，需要共同利益者的参与，强调用户故事和行为;是面向开发者、QA、非技术人员或商业参与者共同参与和理解的开发活动，而不是TDD简单地只关注开发者的方法论；  </p>
</li>
<li><p>TDD测试驱动开发，是一种不同于传统软件开发流程:开发结束再测试介入的新型开发方法。要求把项目按功能点划分，在编写每个功能点前先编写测试代码，然后再编写使测试通过的功能代码，通过测试来推动整个开发工作。</p>
</li>
</ul>
<h2>搭建环境</h2>

<h4>1.下载源文件</h4>

<p><a href="https://github.com/jasmine/jasmine/releases" target="_blank" rel="noopener">jasmine源文件下载地址</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1062695-257a5b3a23ce42f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.png">    </p>
<p>&#160;&#160;&#160;&#160;下载jasmine-standlone-2.5.0.zip即可。这是一个范例，但是可以直接使用。运行起来如下图显示：<br> <img src="http://upload-images.jianshu.io/upload_images/1062695-c601eb879ca4f145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行图"></p>
<h4>2.使用</h4><br>&#160;&#160;&#160;&#160;将下载下来的文件夹中lib文件夹下的jasmine-2.5.0文件夹直接拖入你所需要用的项目。在index.html 中引入下面几句<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/png&quot; href=&quot;lib/jasmine-2.5.0/jasmine_favicon.png&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/jasmine-2.5.0/jasmine.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;lib/jasmine-2.5.0/jasmine.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;lib/jasmine-2.5.0/jasmine-html.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;lib/jasmine-2.5.0/boot.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><br>&#160;&#160;&#160;&#160;之后便可以直接创建对应的测试用例js文件了。<br><br><br><br><h2>jasmine基础语法</h2><br><strong>一个简单的例子</strong><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A suite&quot;, function() &#123;  </span><br><span class="line">    it(&quot;contains spec with an expectation&quot;, function() &#123;  </span><br><span class="line">        expect(true).toBe(true);  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;h3&gt;1.两个核心方法&lt;/h3&gt;</span><br><span class="line">- &lt;h4&gt;describe方法&lt;/h4&gt;  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;describe是jasmine用于描述测试集(Test Suite)的全局函数，作为测试集的开始，一般有两个参数，字符串和方法。字符串作为特定用例组的名字和标题。方法是包含实现用例组的代码。一个测试集合可以包含多个spec(测试点)。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- &lt;h4&gt;it方法&lt;/h4&gt;</span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;jasmine中用方法it来开始specs。it方法和describe方法类似， 同样有两个参数，一个String，一个function；String用来描述测试点（spec），function是具体的测试代码。  </span><br><span class="line"></span><br><span class="line">**示例代码**   </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">describe(&quot;This is an exmaple suite&quot;, function() &#123;</span><br><span class="line">  it(&quot;contains spec with an expectation&quot;, function() &#123;</span><br><span class="line">    expect(true).toBe(true);</span><br><span class="line">    expect(false).toBe(false);</span><br><span class="line">    expect(false).not.toBe(true);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><h3>2.四个核心概念</h3><br><h4>Jasmine四个核心概念：</h4><br> - 分组(Suites)<br> - 用例(Specs)<br> - 期望(Expectations)<br> - 匹配(Matchers)<br><br>- <h4>分组</h4>(Suites)<br>&#160;&#160;&#160;&#160;Suites可以理解为一组测试用例，以函数describe(string,function)封装，describe函数接受两个参数，一个字符串和一个函数。字符串是这个Suites的名字或标题（通常描述下测试内容），函数是实现Suites的代码块。一个Suite可以包含多个Specs，一个Specs可以包括多个expect<br><br>- <h4>用例</h4>用例(Specs)<br>&#160;&#160;&#160;&#160;<strong>Specs</strong>可以理解为一个测试用例，使用全局的Jasmin函数<strong>it</strong>创建。和<strong>describe</strong>一样接受两个参数，一个字符串和一个函数，函数就是要执行的测试代码，字符串就是测试用例的名字。一个<strong>Spec</strong>可以包含多个<strong>expectations</strong>来测试代码。<br><br>- <h4>期望</h4>(Expectations)<br>&#160;&#160;&#160;&#160;Expectations由expect 函数创建。接受一个参数。和Matcher一起联用，设置测试的预期值。返回ture或false。<br>&#160;&#160;&#160;&#160;在分组(<strong>describe</strong>)中可以写多个测试用例(<strong>it</strong>)，也可以再进行分组(<strong>describe</strong>)，在测试用例(<strong>it</strong>)中定义期望表达式(<strong>expect</strong>)和匹配判断(<strong>toBe</strong>)。看一个简单的Demo:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A suite&quot;, function() &#123;//suites</span><br><span class="line">    var a;</span><br><span class="line">    it(&quot;A spec&quot;, function() &#123;//spec</span><br><span class="line">      a = true;</span><br><span class="line">      expect(a).toBe(true);//expectations</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    describe(&quot;a suite&quot;, function() &#123;//inner suites</span><br><span class="line">           it(&quot;a spec&quot;, function() &#123;//spec</span><br><span class="line">           expect(a).toBe(true);//expectations</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br>- <h4>匹配</h4>(Matchers)<br>&#160;&#160;&#160;&#160;Matcher实现断言的比较操作，一个“期望值”与“实际值”的对比，如果结果为true，则通过测试，反之，则失败。每一个matcher都能通过not执行否定判断。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">expect(a).toBe(true);//期望变量a为true</span><br><span class="line">expect(a).toEqual(true);//期望变量a等于true</span><br><span class="line">expect(a).toMatch(/reg/);//期望变量a匹配reg正则表达式，也可以是字符串</span><br><span class="line">expect(a.foo).toBeDefined();//期望a.foo已定义</span><br><span class="line">expect(a.foo).toBeUndefined();//期望a.foo未定义</span><br><span class="line">expect(a).toBeNull();//期望变量a为null</span><br><span class="line">expect(a.isMale).toBeTruthy();//期望a.isMale为真</span><br><span class="line">expect(a.isMale).toBeFalsy();//期望a.isMale为假</span><br><span class="line">expect(true).toEqual(true);//期望true等于true</span><br><span class="line">expect(a).toBeLessThan(b);//期望a小于b</span><br><span class="line">expect(a).toBeGreaterThan(b);//期望a大于b</span><br><span class="line">expect(a).toThrowError(/reg/);//期望a方法抛出异常，异常信息可以是字符串、正则表达式、错误类型以及错误类型和错误信息</span><br><span class="line">expect(a).toThrow();//期望a方法抛出异常</span><br><span class="line">expect(a).toContain(b);//期望a(数组或者对象)包含b</span><br></pre></td></tr></table></figure><br><br>&#160;&#160;&#160;&#160;自定义Matcher（被称为Matcher Factories）实质上是一个函数（该函数的参数可以为空），该函数返回一个闭包，该闭包的本质是一个compare函数，compare函数接受2个参数：actual value 和 expected value。<br>&#160;&#160;&#160;&#160;compare函数必须返回一个带pass属性的结果Object，pass属性是一个Boolean值，表示该Matcher的结果（为true表示该Matcher实际值与预期值匹配，为false表示不匹配），也就是说，实际值与预期值具体的比较操作的结果，存放于pass属性中。<br><br><h4>其他matchers：</h4><br><strong>jasmine.any(Class)–传入构造函数或者类返回数据类型作为期望值，返回true表示实际值和期望值数据类型相同:</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;matches any value&quot;, function() &#123;</span><br><span class="line">    expect(&#123;&#125;).toEqual(jasmine.any(Object));</span><br><span class="line">    expect(12).toEqual(jasmine.any(Number));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><strong>jasmine.anything()–如果实际值不是null或者undefined则返回true:</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;matches anything&quot;, function() &#123;</span><br><span class="line">    expect(1).toEqual(jasmine.anything());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><strong>jasmine.objectContaining({key:value})–实际数组只要匹配到有包含的数值就算匹配通过:</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2,</span><br><span class="line">      bar: &quot;baz&quot;</span><br><span class="line">&#125;;</span><br><span class="line">expect(foo).toEqual(jasmine.objectContaining(&#123;bar: &quot;baz&quot;&#125;));</span><br></pre></td></tr></table></figure><br><br><strong>jasmine.arrayContaining([val1,val2,…])–stringContaining可以匹配字符串的一部分也可以匹配对象内的字符串:</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;foo: &apos;bar&apos;&#125;).toEqual(&#123;foo: jasmine.stringMatching(/^bar$/)&#125;);</span><br><span class="line">expect(&apos;foobarbaz&apos;).toEqual(&#123;foo: jasmine.stringMatching(&apos;bar&apos;)&#125;);</span><br></pre></td></tr></table></figure><br><br><h3>3.Setup和Teardown方法</h3><br>&#160;&#160;&#160;&#160;为了减少重复性的代码，jasmine提供了beforeEach、afterEach、beforeAll、afterAll方法。<br><br>- beforeEach() :在describe函数中每个Spec执行之前执行；<br>- afterEach() :在describe函数中每个Spec执行之后执行;<br>- beforeAll() :在describe函数中所有的Specs执行之前执行，且只执行一次<br>- afterAll () : 在describe函数中所有的Specs执行之后执行，且只执行一次<br><br><br><br><h5>结果如图所示:</h5><br><img src="http://upload-images.jianshu.io/upload_images/1062695-6660e7d9e385fb4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"><br><br><h3>4.describe函数的嵌套</h3><br><br>&#160;&#160;&#160;&#160;每个嵌套的<strong>describe</strong>函数，都可以有自己的<strong>beforeEach</strong>，<strong>afterEach</strong>函数。<br>&#160;&#160;&#160;&#160;在执行每个内层<strong>Spec</strong>时，都会按嵌套的由外及内的顺序执行每个<strong>beforeEach</strong>函数，所以内层<strong>Sepc</strong>可以访问到外层<strong>Sepc</strong>中的<strong>beforeEach</strong>中的数据。类似的，当内层<strong>Spec</strong>执行完成后，会按由内及外的顺序执行每个<strong>afterEach</strong>函数。<br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spec&quot;, function() &#123;</span><br><span class="line">  var foo;</span><br><span class="line"></span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = 0;</span><br><span class="line">    foo += 1;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  afterEach(function() &#123;</span><br><span class="line">    foo = 0;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;is just a function, so it can contain any code&quot;, function() &#123;</span><br><span class="line">    expect(foo).toEqual(1);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;can have more than one expectation&quot;, function() &#123;</span><br><span class="line">    expect(foo).toEqual(1);</span><br><span class="line">    expect(true).toEqual(true);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  describe(&quot;nested inside a second describe&quot;, function() &#123;</span><br><span class="line">    var bar;</span><br><span class="line">    beforeEach(function() &#123;</span><br><span class="line">      bar = 1;</span><br><span class="line">    &#125;);</span><br><span class="line">    it(&quot;can reference both scopes as needed&quot;, function() &#123;</span><br><span class="line">      expect(foo).toEqual(bar);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><h3>5.禁用Suites,挂起Specs</h3><br><br><br>&#160;&#160;&#160;&#160;<strong>Suites</strong>可以被<strong>Disabled</strong>。在<strong>describe</strong>函数名之前添加<strong>x</strong>即可将<strong>Suite</strong>禁用。<br>&#160;&#160;&#160;&#160;被<strong>Disabled</strong>的<strong>Suites</strong>在执行中会被跳过，该<strong>Suite</strong>的结果也不会显示在结果集中。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xdescribe(&quot;A spec&quot;, function() &#123;</span><br><span class="line">  var foo;</span><br><span class="line"></span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = 0;</span><br><span class="line">    foo += 1;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;is just a function, so it can contain any code&quot;, function() &#123;</span><br><span class="line">    expect(foo).toEqual(1);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br>&#160;&#160;&#160;&#160;有3种方法可以将一个Spec标记为Pending。被Pending的Spec不会被执行，但是Spec的名字会在结果集中显示，只是标记为Pending。<br><br>- 如果在Spec函数it的函数名之前添加x（xit），那么该Spec就会被标记为Pending。<br>- 一个没有定义函数体的Sepc也会在结果集中被标记为Pending。<br>- 如果在Spec的函数体中调用pending()函数，那么该Spec也会被标记为Pending。pending()函数接受一个字符串参数，该参数会在结果集中显示在PENDING WITH MESSAGE:之后，作为为何被Pending的原因。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;Pending specs&quot;, function() &#123;</span><br><span class="line"></span><br><span class="line">  xit(&quot;can be declared &apos;xit&apos;&quot;, function() &#123;</span><br><span class="line">    expect(true).toBe(false);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;can be declared with &apos;it&apos; but without a function&quot;);</span><br><span class="line">  </span><br><span class="line">  it(&quot;can be declared by calling &apos;pending&apos; in the spec body&quot;, function() &#123;</span><br><span class="line">    expect(true).toBe(false);</span><br><span class="line">    pending(&apos;this is why it is pending&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><h3>6.Spy追踪</h3><br><h4>&#160;&#160;&#160;&#160;Jasmine具有函数的追踪和反追踪的双重功能，这东西就是Spy。Spy能够存储任何函数调用记录和传入的参数，Spy只存在于describe和it中，在spec执行完之后销毁。</h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spy&quot;, function() &#123;</span><br><span class="line">  var foo, bar = null;</span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = &#123;</span><br><span class="line">      setBar: function(value) &#123;</span><br><span class="line">        bar = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    spyOn(foo, &apos;setBar&apos;);//给foo对象的setBar函数绑定追踪</span><br><span class="line">    foo.setBar(123);</span><br><span class="line">    foo.setBar(456, &apos;another param&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;tracks that the spy was called&quot;, function() &#123;</span><br><span class="line">    expect(foo.setBar).toHaveBeenCalled();//toHaveBeenCalled用来匹配测试函数是否被调用过</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;tracks all the arguments of its calls&quot;, function() &#123;</span><br><span class="line">    expect(foo.setBar).toHaveBeenCalledWith(123);//toHaveBeenCalledWith用来匹配测试函数被调用时的参数列表</span><br><span class="line">    expect(foo.setBar).toHaveBeenCalledWith(456, &apos;another param&apos;);//期望foo.setBar已经被调用过，且传入参数为[456, &apos;another param&apos;]</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;stops all execution on a function&quot;, function() &#123;</span><br><span class="line">    expect(bar).toBeNull();//用例没有执行foo.setBar,bar为null</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4>&#160;&#160;&#160;&#160;and.callThrough–spy链式调用and.callThrough后，在获取spy的同时，调用实际的函数。</h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spy, when configured to call through&quot;, function() &#123;</span><br><span class="line">  var foo, bar, fetchedBar;</span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = &#123;</span><br><span class="line">      setBar: function(value) &#123;</span><br><span class="line">        bar = value;</span><br><span class="line">      &#125;,</span><br><span class="line">      getBar: function() &#123;</span><br><span class="line">        return bar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    spyOn(foo, &apos;getBar&apos;).and.callThrough();//调用and.callThrough方法</span><br><span class="line">    foo.setBar(123);</span><br><span class="line">    fetchedBar = foo.getBar();//因为and.callThrough，这里执行的是foo.getBar方法，而不是spy的方法</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;tracks that the spy was called&quot;, function() &#123;</span><br><span class="line">    expect(foo.getBar).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should not effect other functions&quot;, function() &#123;</span><br><span class="line">    expect(bar).toEqual(123);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;when called returns the requested value&quot;, function() &#123;</span><br><span class="line">    expect(fetchedBar).toEqual(123);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4>&#160;&#160;&#160;&#160;and.returnValue–spy链式调用and.returnValue 后，任何时候调用该方法都只会返回指定的值，</h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spy, when configured to fake a return value&quot;, function() &#123;</span><br><span class="line">  var foo, bar, fetchedBar;</span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = &#123;</span><br><span class="line">      setBar: function(value) &#123;</span><br><span class="line">        bar = value;</span><br><span class="line">      &#125;,</span><br><span class="line">      getBar: function() &#123;</span><br><span class="line">        return bar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    spyOn(foo, &quot;getBar&quot;).and.returnValue(745);//指定返回值为745</span><br><span class="line">    foo.setBar(123);</span><br><span class="line">    fetchedBar = foo.getBar();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;tracks that the spy was called&quot;, function() &#123;</span><br><span class="line">    expect(foo.getBar).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should not effect other functions&quot;, function() &#123;</span><br><span class="line">    expect(bar).toEqual(123);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;when called returns the requested value&quot;, function() &#123;</span><br><span class="line">    expect(fetchedBar).toEqual(745);//默认返回指定的returnValue值</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4>&#160;&#160;&#160;&#160;and.callFake–spy链式添加and.callFake相当于用新的方法替换spy的方法 </h4> 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spy, when configured with an alternate implementation&quot;, function() &#123;</span><br><span class="line">  var foo, bar, fetchedBar;</span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = &#123;</span><br><span class="line">      setBar: function(value) &#123;</span><br><span class="line">        bar = value;</span><br><span class="line">      &#125;,</span><br><span class="line">      getBar: function() &#123;</span><br><span class="line">        return bar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    spyOn(foo, &quot;getBar&quot;).and.callFake(function() &#123;//指定callFake方法</span><br><span class="line">      return 1001;</span><br><span class="line">    &#125;);</span><br><span class="line">    foo.setBar(123);</span><br><span class="line">    fetchedBar = foo.getBar();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;tracks that the spy was called&quot;, function() &#123;</span><br><span class="line">    expect(foo.getBar).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should not effect other functions&quot;, function() &#123;</span><br><span class="line">    expect(bar).toEqual(123);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;when called returns the requested value&quot;, function() &#123;</span><br><span class="line">    expect(fetchedBar).toEqual(1001);//执行callFake方法，返回1001</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p></p><h4>&#160;&#160;&#160;&#160;and.throwError–spy链式调用and.callError后，任何时候调用该方法都会抛出异常错误信息: </h4><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spy, when configured to throw an error&quot;, function() &#123;</span><br><span class="line">  var foo, bar;</span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = &#123;</span><br><span class="line">      setBar: function(value) &#123;</span><br><span class="line">        bar = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    spyOn(foo, &quot;setBar&quot;).and.throwError(&quot;error&quot;);//指定throwError</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;throws the value&quot;, function() &#123;</span><br><span class="line">    expect(function() &#123;</span><br><span class="line">      foo.setBar(123)</span><br><span class="line">    &#125;).toThrowError(&quot;error&quot;);//抛出错误异常</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p></p><h4>&#160;&#160;&#160;&#160;and.stub–spy恢复到原始状态，不执行任何操作。直接看下代码: </h4><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;A spy&quot;, function() &#123;</span><br><span class="line">  var foo, bar = null;</span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    foo = &#123;</span><br><span class="line">      setBar: function(value) &#123;</span><br><span class="line">        bar = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    spyOn(foo, &apos;setBar&apos;).and.callThrough();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;can call through and then stub in the same spec&quot;, function() &#123;</span><br><span class="line">    foo.setBar(123);</span><br><span class="line">    expect(bar).toEqual(123);</span><br><span class="line">    foo.setBar.and.stub();//把foo.setBar设置为原始状态，and.callThrough无效</span><br><span class="line">    bar = null;</span><br><span class="line">    foo.setBar(123);//执行赋值无效</span><br><span class="line">    expect(bar).toBe(null);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>
<p></p><h4>&#160;&#160;&#160;&#160;Spy的其他方法  </h4><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.calls.any():记录spy是否被访问过，如果没有，则返回false，否则，返回true；</span><br><span class="line">.calls.count():记录spy被访问过的次数；</span><br><span class="line">.calls.argsFor(index):返回指定索引的参数；</span><br><span class="line">.calls.allArgs():返回所有函数调用的参数记录数组；</span><br><span class="line">.calls.all ():返回所有函数调用的上下文、参数和返回值；</span><br><span class="line">.calls.mostRecent():返回最近一次函数调用的上下文、参数和返回值；</span><br><span class="line">.calls.first():返回第一次函数调用的上下文、参数和返回值；</span><br><span class="line">.calls.reset():清除spy的所有调用记录；</span><br></pre></td></tr></table></figure><p></p>
<p></p><h4>参考：</h4><br><a href="http://jasmine.github.io/2.5/introduction.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://www.open-open.com/lib/view/open1402751449322.html" target="_blank" rel="noopener">jasmine测试框架简介</a><br><a href="http://www.cnblogs.com/zhcncn/p/4330112.html" target="_blank" rel="noopener">JavaScript单元测试框架-Jasmine</a><br><a href="http://www.tuicool.com/articles/J7vUny" target="_blank" rel="noopener">JavaScript 单元测试框架：Jasmine 初探</a><br><a href="http://blog.csdn.net/luqin1988/article/details/8701611" target="_blank" rel="noopener">web前端开发七武器—Jasmine入门教程(上)</a><br><a href="http://www.jianshu.com/p/cbfbfe65d777" target="_blank" rel="noopener">前端测试-jasmine</a><br><a href="http://www.jianshu.com/p/5254b4b1a5de" target="_blank" rel="noopener">开启JavaScript测试之路–Jasmine</a>  <p></p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="https://github.com/Yulingsong">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">Unit Test</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">1.0.1.</span> <span class="toc-text">单元测试概念（Unit Testing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">1.0.2.</span> <span class="toc-text">单元测试必要性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">Jasmine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">搭建环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.下载源文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">jasmine基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">2.四个核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.1.</span> <span class="toc-text">Jasmine四个核心概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.2.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.3.</span> <span class="toc-text">用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.4.</span> <span class="toc-text">期望</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.5.</span> <span class="toc-text">匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.6.</span> <span class="toc-text">其他matchers：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">3.Setup和Teardown方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">结果如图所示:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.3.</span> <span class="toc-text">4.describe函数的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.4.</span> <span class="toc-text">5.禁用Suites,挂起Specs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.</span> <span class="toc-text">6.Spy追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.1.</span> <span class="toc-text">    Jasmine具有函数的追踪和反追踪的双重功能，这东西就是Spy。Spy能够存储任何函数调用记录和传入的参数，Spy只存在于describe和it中，在spec执行完之后销毁。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.2.</span> <span class="toc-text">    and.callThrough–spy链式调用and.callThrough后，在获取spy的同时，调用实际的函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.3.</span> <span class="toc-text">    and.returnValue–spy链式调用and.returnValue 后，任何时候调用该方法都只会返回指定的值，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.4.</span> <span class="toc-text">    and.callFake–spy链式添加and.callFake相当于用新的方法替换spy的方法 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.5.</span> <span class="toc-text">    and.throwError–spy链式调用and.callError后，任何时候调用该方法都会抛出异常错误信息: </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.6.</span> <span class="toc-text">    and.stub–spy恢复到原始状态，不执行任何操作。直接看下代码: </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.7.</span> <span class="toc-text">    Spy的其他方法  </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">4.5.8.</span> <span class="toc-text">参考：</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&text=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&is_video=false&description=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=web学习笔记01-Jasmine-Unit-Test&body=Check out this article: http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&title=web学习笔记01-Jasmine-Unit-Test"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2016/09/05/web学习笔记01-Jasmine-Unit-Test/&name=web学习笔记01-Jasmine-Unit-Test&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 郁凌松
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="https://github.com/Yulingsong">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-118285497-1', 'auto');
        ga('send', 'pageview');
    </script>



